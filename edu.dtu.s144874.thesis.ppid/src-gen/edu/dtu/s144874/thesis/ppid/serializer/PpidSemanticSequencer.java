/*
 * generated by Xtext 2.24.0
 */
package edu.dtu.s144874.thesis.ppid.serializer;

import com.google.inject.Inject;
import edu.dtu.s144874.thesis.ppid.ppid.ArrayType;
import edu.dtu.s144874.thesis.ppid.ppid.EndRule;
import edu.dtu.s144874.thesis.ppid.ppid.Entity;
import edu.dtu.s144874.thesis.ppid.ppid.EntityReference;
import edu.dtu.s144874.thesis.ppid.ppid.Model;
import edu.dtu.s144874.thesis.ppid.ppid.Output;
import edu.dtu.s144874.thesis.ppid.ppid.OutputProperty;
import edu.dtu.s144874.thesis.ppid.ppid.OutputValue;
import edu.dtu.s144874.thesis.ppid.ppid.PpidPackage;
import edu.dtu.s144874.thesis.ppid.ppid.Property;
import edu.dtu.s144874.thesis.ppid.ppid.PropertyReference;
import edu.dtu.s144874.thesis.ppid.ppid.Rule;
import edu.dtu.s144874.thesis.ppid.ppid.SimpleDataType;
import edu.dtu.s144874.thesis.ppid.ppid.Sink;
import edu.dtu.s144874.thesis.ppid.ppid.Source;
import edu.dtu.s144874.thesis.ppid.ppid.SourceUpdate;
import edu.dtu.s144874.thesis.ppid.ppid.StartRule;
import edu.dtu.s144874.thesis.ppid.ppid.UpdateAbove;
import edu.dtu.s144874.thesis.ppid.ppid.UpdateBelow;
import edu.dtu.s144874.thesis.ppid.ppid.UpdateChange;
import edu.dtu.s144874.thesis.ppid.ppid.UpdateIs;
import edu.dtu.s144874.thesis.ppid.ppid.UpdateNot;
import edu.dtu.s144874.thesis.ppid.services.PpidGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class PpidSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PpidGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PpidPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PpidPackage.ARRAY_TYPE:
				sequence_ArrayType(context, (ArrayType) semanticObject); 
				return; 
			case PpidPackage.END_RULE:
				sequence_EndRule(context, (EndRule) semanticObject); 
				return; 
			case PpidPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case PpidPackage.ENTITY_REFERENCE:
				sequence_EntityReference(context, (EntityReference) semanticObject); 
				return; 
			case PpidPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case PpidPackage.OUTPUT:
				sequence_Output(context, (Output) semanticObject); 
				return; 
			case PpidPackage.OUTPUT_PROPERTY:
				sequence_OutputProperty(context, (OutputProperty) semanticObject); 
				return; 
			case PpidPackage.OUTPUT_VALUE:
				sequence_OutputValue(context, (OutputValue) semanticObject); 
				return; 
			case PpidPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case PpidPackage.PROPERTY_REFERENCE:
				sequence_PropertyReference(context, (PropertyReference) semanticObject); 
				return; 
			case PpidPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case PpidPackage.SIMPLE_DATA_TYPE:
				sequence_SimpleDataType(context, (SimpleDataType) semanticObject); 
				return; 
			case PpidPackage.SINK:
				sequence_Sink(context, (Sink) semanticObject); 
				return; 
			case PpidPackage.SOURCE:
				sequence_Source(context, (Source) semanticObject); 
				return; 
			case PpidPackage.SOURCE_UPDATE:
				sequence_SourceUpdate(context, (SourceUpdate) semanticObject); 
				return; 
			case PpidPackage.START_RULE:
				sequence_StartRule(context, (StartRule) semanticObject); 
				return; 
			case PpidPackage.UPDATE_ABOVE:
				sequence_UpdateAbove(context, (UpdateAbove) semanticObject); 
				return; 
			case PpidPackage.UPDATE_BELOW:
				sequence_UpdateBelow(context, (UpdateBelow) semanticObject); 
				return; 
			case PpidPackage.UPDATE_CHANGE:
				sequence_UpdateChange(context, (UpdateChange) semanticObject); 
				return; 
			case PpidPackage.UPDATE_IS:
				sequence_UpdateIs(context, (UpdateIs) semanticObject); 
				return; 
			case PpidPackage.UPDATE_NOT:
				sequence_UpdateNot(context, (UpdateNot) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Type returns ArrayType
	 *     ArrayType returns ArrayType
	 *
	 * Constraint:
	 *     type=Type
	 */
	protected void sequence_ArrayType(ISerializationContext context, ArrayType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.ARRAY_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.ARRAY_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayTypeAccess().getTypeTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EndRule returns EndRule
	 *
	 * Constraint:
	 *     rule=Rule
	 */
	protected void sequence_EndRule(ISerializationContext context, EndRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.END_RULE__RULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.END_RULE__RULE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEndRuleAccess().getRuleRuleParserRuleCall_1_0(), semanticObject.getRule());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns EntityReference
	 *     EntityReference returns EntityReference
	 *
	 * Constraint:
	 *     entity=[Entity|ID]
	 */
	protected void sequence_EntityReference(ISerializationContext context, EntityReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.ENTITY_REFERENCE__ENTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.ENTITY_REFERENCE__ENTITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntityReferenceAccess().getEntityEntityIDTerminalRuleCall_0_1(), semanticObject.eGet(PpidPackage.Literals.ENTITY_REFERENCE__ENTITY, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Entity
	 *
	 * Constraint:
	 *     (name=ID properties+=Property*)
	 */
	protected void sequence_Entity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         (entites+=Entity* ((rules+=Rule+ end=EndRule) | end=EndRule)) | 
	 *         (entites+=Entity* sources+=Source+ ((rules+=Rule+ end=EndRule) | end=EndRule)) | 
	 *         (
	 *             ((entites+=Entity* sinks+=Sink+) | (entites+=Entity* sources+=Source+ sinks+=Sink+) | sinks+=Sink+) 
	 *             ((rules+=Rule+ end=EndRule) | end=EndRule)
	 *         ) | 
	 *         (
	 *             (
	 *                 (entites+=Entity* ((sinks+=Sink+ rules+=Rule+) | rules+=Rule+)) | 
	 *                 (entites+=Entity* sources+=Source+ ((sinks+=Sink+ rules+=Rule+) | rules+=Rule+)) | 
	 *                 (sinks+=Sink+ rules+=Rule+) | 
	 *                 rules+=Rule+
	 *             )? 
	 *             start=StartRule 
	 *             end=EndRule
	 *         ) | 
	 *         (rules+=Rule+ end=EndRule) | 
	 *         end=EndRule
	 *     )?
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputProperty returns OutputProperty
	 *
	 * Constraint:
	 *     (name=ID value=OutputValue)
	 */
	protected void sequence_OutputProperty(ISerializationContext context, OutputProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.OUTPUT_PROPERTY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.OUTPUT_PROPERTY__NAME));
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.OUTPUT_PROPERTY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.OUTPUT_PROPERTY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutputPropertyAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOutputPropertyAccess().getValueOutputValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OutputValue returns OutputValue
	 *
	 * Constraint:
	 *     (valueInt=INT | valueString=STRING | valueRef=PropertyReference)
	 */
	protected void sequence_OutputValue(ISerializationContext context, OutputValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Output returns Output
	 *
	 * Constraint:
	 *     (properties+=OutputProperty properties+=OutputProperty*)
	 */
	protected void sequence_Output(ISerializationContext context, Output semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyReference returns PropertyReference
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_PropertyReference(ISerializationContext context, PropertyReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.PROPERTY_REFERENCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.PROPERTY_REFERENCE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyReferenceAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.PROPERTY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.PROPERTY__NAME));
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.PROPERTY__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.PROPERTY__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPropertyAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (updates+=SourceUpdate updates+=SourceUpdate* output=Output? sink=[Sink|ID])
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns SimpleDataType
	 *     SimpleDataType returns SimpleDataType
	 *
	 * Constraint:
	 *     type=PrimitiveType
	 */
	protected void sequence_SimpleDataType(ISerializationContext context, SimpleDataType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.SIMPLE_DATA_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.SIMPLE_DATA_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleDataTypeAccess().getTypePrimitiveTypeEnumRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sink returns Sink
	 *
	 * Constraint:
	 *     (name=ID entity=[Entity|ID])
	 */
	protected void sequence_Sink(ISerializationContext context, Sink semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.SINK__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.SINK__NAME));
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.SINK__ENTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.SINK__ENTITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSinkAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSinkAccess().getEntityEntityIDTerminalRuleCall_2_0_1(), semanticObject.eGet(PpidPackage.Literals.SINK__ENTITY, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SourceUpdate returns SourceUpdate
	 *
	 * Constraint:
	 *     (source=[Source|ID] property=[Property|ID] update=Update)
	 */
	protected void sequence_SourceUpdate(ISerializationContext context, SourceUpdate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.SOURCE_UPDATE__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.SOURCE_UPDATE__SOURCE));
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.SOURCE_UPDATE__PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.SOURCE_UPDATE__PROPERTY));
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.SOURCE_UPDATE__UPDATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.SOURCE_UPDATE__UPDATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSourceUpdateAccess().getSourceSourceIDTerminalRuleCall_0_0_1(), semanticObject.eGet(PpidPackage.Literals.SOURCE_UPDATE__SOURCE, false));
		feeder.accept(grammarAccess.getSourceUpdateAccess().getPropertyPropertyIDTerminalRuleCall_2_0_1(), semanticObject.eGet(PpidPackage.Literals.SOURCE_UPDATE__PROPERTY, false));
		feeder.accept(grammarAccess.getSourceUpdateAccess().getUpdateUpdateParserRuleCall_4_0(), semanticObject.getUpdate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Source returns Source
	 *
	 * Constraint:
	 *     (name=ID topic=STRING entity=[Entity|ID])
	 */
	protected void sequence_Source(ISerializationContext context, Source semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.SOURCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.SOURCE__NAME));
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.SOURCE__TOPIC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.SOURCE__TOPIC));
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.SOURCE__ENTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.SOURCE__ENTITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSourceAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSourceAccess().getTopicSTRINGTerminalRuleCall_2_0(), semanticObject.getTopic());
		feeder.accept(grammarAccess.getSourceAccess().getEntityEntityIDTerminalRuleCall_3_0_1(), semanticObject.eGet(PpidPackage.Literals.SOURCE__ENTITY, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StartRule returns StartRule
	 *
	 * Constraint:
	 *     rule=Rule
	 */
	protected void sequence_StartRule(ISerializationContext context, StartRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.START_RULE__RULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.START_RULE__RULE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStartRuleAccess().getRuleRuleParserRuleCall_1_0(), semanticObject.getRule());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Update returns UpdateAbove
	 *     UpdateAbove returns UpdateAbove
	 *
	 * Constraint:
	 *     n=INT
	 */
	protected void sequence_UpdateAbove(ISerializationContext context, UpdateAbove semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.UPDATE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.UPDATE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpdateAboveAccess().getNINTTerminalRuleCall_2_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Update returns UpdateBelow
	 *     UpdateBelow returns UpdateBelow
	 *
	 * Constraint:
	 *     n=INT
	 */
	protected void sequence_UpdateBelow(ISerializationContext context, UpdateBelow semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.UPDATE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.UPDATE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpdateBelowAccess().getNINTTerminalRuleCall_2_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Update returns UpdateChange
	 *     UpdateChange returns UpdateChange
	 *
	 * Constraint:
	 *     (n=INT m=INT)
	 */
	protected void sequence_UpdateChange(ISerializationContext context, UpdateChange semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.UPDATE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.UPDATE__N));
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.UPDATE_CHANGE__M) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.UPDATE_CHANGE__M));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpdateChangeAccess().getNINTTerminalRuleCall_2_0(), semanticObject.getN());
		feeder.accept(grammarAccess.getUpdateChangeAccess().getMINTTerminalRuleCall_4_0(), semanticObject.getM());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Update returns UpdateIs
	 *     UpdateIs returns UpdateIs
	 *
	 * Constraint:
	 *     n=INT
	 */
	protected void sequence_UpdateIs(ISerializationContext context, UpdateIs semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.UPDATE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.UPDATE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpdateIsAccess().getNINTTerminalRuleCall_2_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Update returns UpdateNot
	 *     UpdateNot returns UpdateNot
	 *
	 * Constraint:
	 *     n=INT
	 */
	protected void sequence_UpdateNot(ISerializationContext context, UpdateNot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PpidPackage.Literals.UPDATE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PpidPackage.Literals.UPDATE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpdateNotAccess().getNINTTerminalRuleCall_2_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
}
